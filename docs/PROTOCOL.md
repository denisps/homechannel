# Protocol Specification

This document describes the communication protocols used by HomeChannel.

## Overview

![Protocol Flow Diagram](protocol-flow.svg)

*Complete communication flow showing server registration, keepalive, and client connection establishment.*

## UDP Protocol (Server ↔ Coordinator)

Server initiates UDP connection to coordinator. All messages use binary protocol for minimal fingerprinting and overhead.

### Binary Protocol Format

All UDP messages follow this format:

```
[Version (1 byte)][Type (1 byte)][Payload (variable length)]
```

**Protocol Version**: `0x01`

**Message Types**:
- `0x01` - HELLO (Phase 1: DoS prevention)
- `0x02` - HELLO_ACK (Phase 2: Tag verification, rate-limited)
- `0x03` - ECDH Init (Phase 3 of registration)
- `0x04` - ECDH Response (Phase 4 of registration)
- `0x05` - Registration (Phase 5, encrypted)
- `0x06` - Ping (keepalive)
- `0x07` - Heartbeat (challenge refresh)
- `0x08` - Answer (SDP response)
- `0x09` - Migrate (coordinator migration/failover)
- `0xFF` - ERROR (Rate limiting, not sent for HELLO)

### Five-Phase Registration with DoS Protection

Registration uses a multi-phase approach with tag-based DoS protection before expensive X25519/X448 operations. X25519/X448 key exchange establishes a shared secret before sending any sensitive data. No Ed25519/Ed448 public keys or signatures are transmitted unencrypted.

#### Phase 1: HELLO (Server → Coordinator)

Server sends a random 4-byte tag to initiate the handshake:

```
Binary: [0x01][0x01][Binary Payload]
```

Binary Payload Format:
```
[serverTag(4)]
```

Fields:
- `serverTag` (4 bytes): Random tag generated by server

**Security & DoS Protection**:
- Minimal processing required from coordinator
- **Source IP:port cannot be trusted** at this stage - only used for reply routing
- No expensive cryptographic operations
- No server identity revealed

**Rate Limiting**: Coordinator rate-limits **replies** (HELLO_ACK), not incoming HELLOs, since source IP cannot be trusted. No ERROR responses are sent to HELLOs to prevent amplification attacks.

#### Phase 2: HELLO_ACK (Coordinator → Server)

Coordinator echoes server's tag and adds its own tag:

```
Binary: [0x01][0x02][Binary Payload]
```

Binary Payload Format:
```
[serverTag(4)][coordinatorTag(4)]
```

Fields:
- `serverTag` (4 bytes): Echo of server's tag
- `coordinatorTag` (4 bytes): Random tag generated by coordinator

**Security**: Server verifies its tag to confirm response is for its request. Coordinator's tag will be used in Phase 3 to prevent replay/amplification of expensive X25519/X448 operations. Coordinator does not store server's tag (server will echo it back).

#### Phase 3: ECDH Init (Server → Coordinator)

Server sends X25519/X448 public key along with coordinator's tag:

```
Binary: [0x01][0x03][Binary Payload]
```

Binary Payload Format:
```
[coordinatorTag(4)][ecdhPubKeyLen(1)][ecdhPubKey]
```

Fields:
- `coordinatorTag` (4 bytes): Echo of coordinator's tag from HELLO_ACK
- `ecdhPubKeyLen` (1 byte): Length of X25519/X448 public key (SPKI DER; typically ~44 bytes for X25519, ~90 bytes for X448)
- `ecdhPubKey` (variable): X25519/X448 public key (SPKI DER bytes)

**Security**: Coordinator verifies its tag before performing expensive X25519/X448 operations, preventing DoS amplification. No server identity revealed yet. Observer cannot determine which server is connecting.

#### Phase 4: ECDH Response (Coordinator → Server)

#### Phase 4: ECDH Response (Coordinator → Server)

Coordinator responds with its X25519/X448 public key and encrypted signature:

```
Binary: [0x01][0x04][Binary Payload]
```

Binary Payload Format:
```
[ecdhPubKeyLen(1)][ecdhPubKey][encryptedData]
```

Fields:
- `ecdhPubKeyLen` (1 byte): Length of coordinator's X25519/X448 public key
- `ecdhPubKey` (variable): Coordinator's X25519/X448 public key (SPKI DER bytes)
- `encryptedData` (variable): AES-GCM encrypted signature data

Both parties compute an X25519/X448 shared secret. Coordinator signs **both ECDH public keys** (coordinator's + server's) with its Ed448 private key (configurable Ed25519) to bind them together and prevent MITM attacks. The signature data is encrypted using AES-GCM with key derived from the shared secret:

```javascript
{
  timestamp: 1234567890,
  signature: 'hex-signature-of-both-key-agreement-keys'
}
```

Server uses its own X25519/X448 public key (which it already knows) and the coordinator's X25519/X448 public key (received in this message) to verify the signature and confirm coordinator's identity.

**Security**: Coordinator proves its identity and binds both X25519/X448 keys together. Observer cannot impersonate coordinator, perform MITM attack, or see the signature. No redundant transmission of keys.

#### Phase 5: Registration (Server → Coordinator)

Server sends encrypted registration data using AES-GCM with key derived from the X25519/X448 shared secret:

```
Binary: [0x01][0x05][AES-GCM Encrypted Payload]
```

Encrypted JSON payload:
```javascript
{
  serverPublicKey: 'pem-key',
  timestamp: 1234567890,
  payload: {
    challenge: 'hex-string',
    challengeAnswerHash: 'hex-string'
  },
  signature: 'eddsa-hex-signature'
}
```

The signature is computed over the JSON representation of:
```javascript
{
  ecdhKeys: 'hex-concat-of-server-and-coordinator-ecdh-keys',
  serverPublicKey,
  timestamp,
  payload
}
```

By signing both ECDH public keys, the server binds them together. The coordinator verifies this using the session-stored X25519/X448 keys, preventing MITM attacks where an attacker could substitute their own ECDH key. No redundant transmission of keys - coordinator already knows its own ECDH public key.

**Security**: Server identity (Ed25519/Ed448 public key) and challenge data only revealed after encryption established. Both X25519/X448 keys are cryptographically bound via signature. Observer cannot see challenge, identify server, or perform MITM attack. Minimal data transmission.

After registration, the `challengeAnswerHash` (expectedAnswer) becomes the shared secret for all future communication.

### Keepalive Ping (Optimized - No Payload)

Sent every ~30 seconds:

```
Binary: [0x01][0x06]
```

**Optimization**: Ping messages contain no payload and require no encryption/decryption. The coordinator simply updates the server's timestamp upon receiving a ping from a known IP:port. This minimizes CPU usage and network overhead for frequent keepalive messages.

### Challenge Refresh (AES-GCM Encrypted Payload)

Sent every ~10 minutes. AES-GCM provides both encryption and authentication:

```
Binary: [0x01][0x07][Encrypted payload]
```

Encrypted JSON:
```javascript
{
  type: 'heartbeat',
  payload: {
    newChallenge: 'refreshed-challenge-hex',
    challengeAnswerHash: 'new-expected-hash'
  }
}
```

**Security**: AES-GCM authenticated encryption ensures that only the legitimate server (with the correct `expectedAnswer` key) can send valid heartbeat messages. If decryption succeeds, authentication is guaranteed.

### SDP Answer (AES-GCM Encrypted Payload)

Response to client offer:

```
Binary: [0x01][0x08][Encrypted payload]
```

Encrypted JSON:
```javascript
{
  type: 'answer',
  serverPublicKey: 'base64-encoded-ed25519-or-ed448-public-key',
  sessionId: 'client-session-id',
  timestamp: Date.now(),
  payload: {
    sdp: { type: 'answer', sdp: '...' },
    candidates: [
      { candidate: '...', sdpMLineIndex: 0, sdpMid: 'data' },
      // ... all ICE candidates
    ]
  },
  signature: 'hex-encoded-eddsa-signature'
}
```

### Migrate (AES-GCM Encrypted Payload)

Coordinator requests server to migrate to a different coordinator:

```
Binary: [0x01][0x09][Encrypted payload]
```

Encrypted JSON:
```javascript
{
  type: 'migrate',
  payload: {
    host: 'new-coordinator.example.com',  // or IP address
    port: 3478,
    publicKey: 'base64-encoded-coordinator-public-key'
  }
}
```

**Behavior**: 
- Server receives migration request after AES-GCM key is established
- Server saves failover coordinator info to disk (`failover-coordinator.json`)
- Server immediately attempts to register with new coordinator
- On successful registration, server switches to new coordinator
- Old connection is gracefully closed
- Migration failure does not interrupt current connection

**Use Cases**:
- Load balancing across multiple coordinators
- Coordinator maintenance and upgrades
- Geographic load distribution
- Failover during coordinator issues

### ERROR (No Payload)

Sent by coordinator when client is rate-limited or banned:

```
Binary: [0x01][0xFF]
```

**Purpose**: Notifies client of rate limiting or temporary ban. Client should back off and retry later. No payload needed - message type alone conveys the error.

## HTTPS Protocol (Client ↔ Coordinator)

Client connects via standard HTTPS polling (no WebSockets).

### List Servers

```
POST /api/servers

Request:
{
  serverPublicKeys: ['key1-hash', 'key2-hash']
}

Response:
{
  servers: [
    {
      publicKeyHash: 'key1-hash',
      name: 'Server Name',
      online: true,
      challenge: 'current-challenge-hex'
    }
  ]
}
```

### Initiate Connection

Client provides challenge answer with SDP offer and all ICE candidates:

```
POST /api/connect

Request:
{
  serverPublicKey: 'target-server-public-key-hash',
  challengeAnswer: 'hash-of-challenge-plus-password',
  payload: {
    sdp: { type: 'offer', sdp: '...' },
    candidates: [
      { candidate: '...', sdpMLineIndex: 0, sdpMid: 'data' },
      // ... all ICE candidates
    ]
  },
  timestamp: Date.now()
}

Response:
{
  success: true,
  sessionId: 'unique-session-id',
  message: 'Waiting for server response'
}
```

### Poll for Server Response

```
POST /api/poll

Request:
{
  sessionId: 'unique-session-id',
  lastUpdate: 1234567890
}

Response (when ready):
{
  success: true,
  payload: {
    sdp: { type: 'answer', sdp: '...' },
    candidates: [
      // ... all ICE candidates from server
    ]
  },
  serverSignature: 'server-eddsa-signature',
  serverSignatureAlgorithm: 'ed448'
}

Response (waiting):
{
  success: false,
  waiting: true
}
```

## Message Flow

### Server Registration

1. Server generates challenge and expectedAnswer
2. Server sends unencrypted registration to coordinator (Ed448-signed, configurable Ed25519)
3. Coordinator verifies signature and stores server info
4. Server identified by IP:port for ongoing communication

### Client Connection

1. Client gets server's challenge from coordinator
2. Client computes challenge answer from password
3. Client gathers all ICE candidates
4. Client sends offer + candidates + challenge answer
5. Coordinator verifies challenge answer
6. Coordinator relays to server via encrypted UDP
7. Server sends encrypted answer + candidates
8. Coordinator relays to client via HTTPS
9. Direct WebRTC datachannel established

### Keepalive

- Server sends encrypted ping every ~30s
- Coordinator updates server timestamp
- No response needed (minimal overhead)

### Challenge Refresh

- Server sends encrypted heartbeat every ~10 minutes
- Contains new challenge and HMAC
- Coordinator verifies HMAC and updates challenge

## Encryption

### Binary Protocol

All UDP messages use binary protocol format to avoid fingerprinting:

```
[Version (1 byte)][Type (1 byte)][Payload (variable length)]
```

- **Version**: 0x01
- **Types**: 0x01=ECDH init, 0x02=ECDH response, 0x03=register, 0x04=ping, 0x05=heartbeat, 0x06=answer

### AES-GCM Encryption

Most UDP messages after registration use AES-256-GCM encryption:

- **Key**: Derived from expectedAnswer using SHA-256
- **IV**: Random 12 bytes per message
- **Auth Tag**: 16 bytes (appended after IV)
- **Format**: `[IV (12 bytes)][AuthTag (16 bytes)][Ciphertext]`
- **Payload**: JSON message (encrypted in binary format)

**Exceptions**:
- **ECDH Init/Response**: Uses shared secret derived from X25519/X448
- **Ping**: No payload, no encryption (optimized for minimal overhead)

## Signatures

- **EdDSA**: Ed448 (default) or Ed25519 (configurable)
- **HMAC**: SHA-256, using expectedAnswer as key
- **Timing-safe**: All comparisons use constant-time operations
